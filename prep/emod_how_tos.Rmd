---
title: "EMOD How To's"
author: "Anne Stahlfeld & Tobias Holden"
date: "`r Sys.Date()`"
output: html_document
---

These "How To's" are user generated tips & tricks on how to complete many common tasks in EMOD. They are tailored to the malaria model.

## Create a demographics file  


<details><summary><span style="color: blue";">1. Parts of a demographics file</span></summary>
<p>



</p>
</details>

<details><summary><span style="color: blue";">2. Creating a demographics file</span></summary>
<p>

*Single-node Sims*


**Spatial Sims -FIX**

First, create a file "my_node.csv" with the following columns:

**Required**

- nodeid (unique # 1-n, for n nodes)
- population (starting population size)

*Optional*

- Other node-specific variables, if any, such as village name, latitude, and longitude

Example "my_node.csv":

| nodeid      | population  |  Village | lat        |  lon        |
| ----------- | ----------- | -------- |----------- |------------ |
| 1           | 1400        | "Obom"   | 5.760759   | -0.4473415  |

Next, run `generate_demographics()`:


```{python, eval=F}
import emodpy_malaria.demographics.MalariaDemographics as Demographics

import os
import pandas as pd
import json
from dtk.tools.demographics.DemographicsGeneratorConcern import WorldBankBirthRateConcern, EquilibriumAgeDistributionConcern, DefaultIndividualAttributesConcern
from dtk.tools.demographics.DemographicsGenerator import DemographicsGenerator
##### Example for Ghana #####
#############################
def generate_demographics(demo_df, demo_fname, days_spread=1) :
  # Get WorldBank birth rate estimate
  # UPDATE country and birthrate_year
  br_concern = WorldBankBirthRateConcern(country="Ghana", birthrate_year=2016)
  chain = [
        DefaultIndividualAttributesConcern(),
        br_concern,
        EquilibriumAgeDistributionConcern(default_birth_rate=br_concern.default_birth_rate),
    ]
    current = DemographicsGenerator.from_dataframe(demo_df,
                                                   population_column_name='population',
                                                   nodeid_column_name='nodeid',
                                                   node_id_from_lat_long=False,
                                                   concerns=chain,
                                                   load_other_columns_as_attributes=True,
                                                   include_columns=['Village'])  # Add any "optional" columns
    with open(demo_fname, 'w') as fout :
      json.dump(current, fout, sort_keys=True,indent=4, separators=(',', ': '))
    
    
df = pd.read_csv(os.path.join(<PATHTOFILE>,"my_node.csv"))  # Modify PATHTOFILE
demo_fname = os.path.join(<INPUTPATH>,"FILENAME_demographics.json") # Modify INPUTPATH and FILENAME
generate_demographics(df, demo_fname)
```
</p>
</details>


## Create multi-node simulations 

<details><summary><span style="color: blue;">1. Generating demographics</span></summary>
<p>

To run simultaneous simulations in multiple nodes, create an input file "my_nodes.csv" with one row for each node.

Ex. "my_nodes.csv"

| nodeid | population | Village |
|--------|------------|---------|
| 1      | 1400       |"Obom"|
| 2      | 2255       |"Kofi Kwei"|
| 3      | 1800       |"Village 3"|

Then, run 

```{python,eval=F}
generate_demographics(df="/my_nodes.csv")
```

</p>
</details>



## Set Node-Specific Parameters

Sometimes we want to vary properties between nodes based on prior knowledge. For any `NodeAttribute` parameters, these can be created simply by specifying them in the `my_nodes.csv` as columns and setting `load_other_columns_as_attributes=True` in the call to `DemographicsGenerator()`.

To set `IndividualAttributes` or `IndividualProperties`, see the following example. Imagine we know the proportion of "high-risk" individuals in each node and want to use this designation to target them for an intervention.

First, we would add a column to our input file representing the high-risk proportion in each node.

Ex. "my_nodes.csv"

| nodeid | lat   | lon   | population | high_risk |
|--------|-------|-------|------------|-----------|
| 1      | 12.11 | -1.47 | 1000       | 0.05      |
| 2      | 12.03 | -1.44 | 1000       | 0.10      |
| 3      | 12.13 | -1.59 | 1000       | 0.15      |
| 17     | 12.06 | -1.48 | 1000       | 0.50      |

Then, when we can assign the "high_risk" property to individuals in each node with the probability listed in the table, by adding the following code to the end of the generate_demographics() function definition, before writing the .json file.

**Coming Soon**

## Add migration between nodes

Multi-node simulations allow for the possibility that humans or vectors will move between nodes. EMOD allows 6 migration types for humans (Local, Regional, Sea, Air, Family, and campaign) and two for vectors (Local and Regional). Other than the campaign type, all other migration types are set via input files and scaling factors in config.json, and these migration rates will remain the same throughout the simulation: we will call these "ongoing migration" to distinguish from the "forced migration" that is set via campaigns.

Multiple migration modes can be used for each agent type (human or vector) simultaneously. For example, we can set up a simulation using Local, Sea, and campaign migration for humans and Local and Regional migration for vectors.

### Ongoing Migration

#### Human Migration Example

#### Vector Migration Example

### Forced Migration

#### A Single Migration Event

#### Periodic Migration

#### Permanent Moves



<details><summary><span style="color: blue;">2. Setting Node-Specific Parameters</span></summary>
<p>

Sometimes we want to vary properties between nodes based on prior knowledge. For any `NodeAttribute` parameters, these 
can be created simply by specifying them in the `my_nodes.csv` as columns and setting `load_other_columns_as_attributes=True` 
in the call to `DemographicsGenerator()`.

To set `IndividualAttributes` or `IndividualProperties`, see the following example. Imagine we know the proportion of 
"high-risk" individuals in each node and want to use this designation to target them for an intervention.

First, we would add a column to our input file representing the high-risk proportion in each node.

| nodeid | population | Village | high_risk |
|--------|------------|---------|-----------|
| 1 | 1400 | "Obom" | 0.05|
| 2 | 2255 | "Kofi Kwei" | 0.10|
| 3 | 1800 | "Village 3" | 0.50|

Then, when we can assign the "high_risk" property to individuals in each node with the probability listed in the table, 
by adding the following code to the end of the `generate_demographics()` function definition, before writing the .json 
file.

```{python, eval=F}
...
current = DemographicsGenerator(...)
for r, row in demo_df.iterrows() :
    current['Nodes'][r]['IndividualProperties'] = [{"Property":"high_risk",
                                                    "Values": ['yes','no'],
                                                    "Initial_Distribution": [row['high_risk'], (1-row['']high_risk)]}]
with open(demo_fname, 'w') as fout :
  json.dump(current, fout, sort_keys=True,indent=4, separators=(',', ': '))
```

We can see this reflected in the demographics file:

```{python, eval=F}
{
     "Metadata": {
          "DateCreated": "dateTime",
          "Tool": "scriptUsedToGenerate",
          "Author": "author",
          "IdReference": "Gridded world grump2.5arcmin",
          "NodeCount": "1"
     },
     "NodeProperties": [
          {...}
     ],
     "Defaults": {
         ...
     },
     "Nodes": [{
          "NodeID": 1,
          "NodeAttributes": {
            "BirthRate": 0.1190,
            "InitialPopulation": 1400,
            "Village": "Obom"
          },
          "IndividualAttributes": {...},
          "IndividualProperties": [
                {
                    "Initial_Distribution": [
                        0.05,
                        0.95
                    ],
                    "Property": "high_risk",
                    "Values": [
                        "yes",
                        "no"
                    ]
                }]},
                
     {
          "NodeID": 2,
          "NodeAttributes": {
            "BirthRate": 0.1690,
            "InitialPopulation": 2255,
            "Village": "Kofi Kwei"
          },
          "IndividualAttributes": {...},
          "IndividualProperties": [
                {
                    "Initial_Distribution": [
                        0.10,
                        0.90
                    ],
                    "Property": "high_risk",
                    "Values": [
                        "yes",
                        "no"
                    ]
                }]},
     {
          "NodeID": 3,
          "NodeAttributes": {
            "BirthRate": 0.2190,
            "InitialPopulation": 1800,
            "Village": "Village 3"
          },
          "IndividualAttributes": {...},
          "IndividualProperties": [
                {
                    "Initial_Distribution": [
                        0.50,
                        0.50
                    ],
                    "Property": "high_risk",
                    "Values": [
                        "yes",
                        "no"
                    ]
                }]}
  }
```

</p>
</details>

## Set up migration between nodes

Multi-node simulations allow for the possibility that humans or vectors will move between nodes.
EMOD allows 6 migration types for humans (Local, Regional, Sea, Air, Family, and campaign) and two 
for vectors (Local and Regional). Other than the campaign type, all other migration types are set via 
input files and scaling factors in config.json, and these migration rates will remain the same throughout
the simulation: we will call these "ongoing migration" to distinguish from the "forced migration" that is 
set via campaigns.

Multiple migration modes can be used for each agent type (human or vector) simultaneously. For example, we 
can set up a simulation using Local, Sea, and campaign migration for humans and Local and Regional migration 
for vectors.

### Ongoing Migration

![figure](/images/01_highlighted.png)

See [EMOD documentation on migration parameters](https://docs.idmod.org/projects/emod-malaria/en/latest/parameter-configuration-migration.html) 
for full parameter list and specifications.

In ongoing migration, heterogeneity in migration can be specified by setting *Enable_Migration_Heterogeneity* to 1 in
config.json and setting migration rate distribution parameters in demographics.json. However, this heterogeneity 
is age-independent, and ongoing migration does not allow the user to specify age-dependent migration patterns.

Local, Regional, Sea, and Air migration types are not implemented differently in EMOD. Their names are
for human-readability and interpretation. We often use Local migration to model short-distance, short-duration 
trips and Regional to model longer-distance, longer-duration trips, but this is not required.

To set up ongoing migration:

1. Create CSV
2. Convert to BIN
3. Update Configuration Parameters

<details><summary><span style="color: blue;">Human Migration example: Local migration</span></summary>
<p>

To specify migration rates, create a file "local_migration.csv" with columns specifying the origin node, destination 
node, and migration rate (1/trip duration). In the example below, people from Node 1 visit node 2 for 5 days (or vice 
versa), and people from Node 3 visit node 2 for 3 days (or vice versa). There is no local human movement between between 
Node 1 and Node 3.

|      |      |    |
|------|------|----|
|Node 1|Node 2| 0.2|
|Node 2|Node 1| 0.2|
|Node 2|Node 3| 0.33|
|Node 3|Node 2| 0.33|

To convert the .csv to a .bin file EMOD can understand, we also require the demographics file:

```{python,eval=F}
demo_fname = "inputs_path/my_demographics_file.json"
with open(demo_fname) as fin:
    demo = json.loads(fin.read())
id_reference = demo['Metadata']['IdReference']
convert_txt_to_bin('local_migration.csv',
                   'local_migration.bin',
                    id_reference=id_reference)
```

To connect that migration file a simulation, we need to change some configuration parameters. 

```{python, eval=F}
cb.update_params({
        # Migration
        'Migration_Model': 'FIXED_RATE_MIGRATION', # turn on human migration
        'Migration_Pattern': 'SINGLE_ROUND_TRIPS', # human trips are round trips (see documentation for other options)
        'Enable_Local_Migration': 1,               # turn on Local human migration
        'Local_Migration_Roundtrip_Duration': 5,   # Local trips last 5 days
        'Local_Migration_Roundtrip_Probability': 1,# traveler returns home in 100% of Local trips 
        'x_Local_Migration': 0.02,                 # Scale factor used to fix the average # of trips per person, per year.
        'Local_Migration_Filename': 'local_migration.bin' # path to migration file
    })
```

Setting up Regional, Sea, and Air migration is analogous, using Regional, Sea, and Air parameters and creating a 
corresponding .bin file.

</p>
</details>

<details><summary><span style="color: blue;">Vector Migration: Local example</span></summary>
<p>

The setup for vector movement between nodes is very similar to that for humans, but with different parameters. 
The table below is an example of a .csv file that can be used to generate a "vector_migration_local.bin" 
specifying equivalent vector migration between 2 adjacent nodes.

|      |      |      |
|------|------|------|
|Node 1|Node 2| 1.0  |
|Node 2|Node 1| 1.0  |

With the following updates to configuration parameters:

```{python, eval=F}
cb.update_params({
        'Enable_Vector_Migration': 1,
        'Enable_Vector_Migration_Local': 1,        
        'x_Vector_Migration_Local': 0.01,  # scale factor to fix average # of trips per vector, per day
        'Vector_Migration_Filename_Local': 'Vector_Local_Migration.bin',
        
        ### Modifying Equation parameters
        #   These must be specified, even if not used. 
        #   The default (no modification) parameters are below
        'Vector_Migration_Modifier_Equation': 'LINEAR',
        'Vector_Migration_Food_Modifier': 0, 
        'Vector_Migration_Habitat_Modifier': 0,
        'Vector_Migration_Stay_Put_Modifier': 0
    })
```

The Modifier parameters allow the user to force vectors to fly preferentially toward blood meals, toward brreding sites, 
or stay in their current location.

</p>
</details>

<p>
</p>

### Forced Migration

You may want to incorporate migration that is different from the normal migration patterns described above: for example, 
to specify a certain demographic group to move at a certain time of year.

<details><summary><span style="color: blue;">Forcing a Single Migration Event</span></summary>
<p>

Make sure the configuration parameters are set to allow migration:

```{python, eval=F}
cb.update_params({
        # Migration
        'Migration_Model': 'FIXED_RATE_MIGRATION',   
        'Migration_Pattern': 'SINGLE_ROUND_TRIPS'
  })
```

To add the migration events to the simulated campaign use add_migration_event(). 

```{python,eval=F}
from dtk.interventions.migrate_to import add_migration_event
# How long after the "start" date should people wait to begin the trip? 
# Here: Trips are staggered evenly over 7 days.
duration_before_leaving = {"Duration_Before_Leaving_Distribution": "UNIFORM_DISTRIBUTION",
                           "Duration_Before_Leaving_Min": 1,
                           "Duration_Before_Leaving_Max": 7}
# How long should the trip last? 
# Here: Each trip lasts exactly 30 days.
duration_at_node = {"Duration_At_Node_Distribution": "CONSTANT_DISTRIBUTION",
                    "Duration_At_Node_Constant": 30}
add_migration_event(cb,
                    start_day=100,    # simulation day on which to start this migration
                    nodesfrom=[2],    # list of node IDs for origin(s)
                    nodeto=1,         # destination node
                    coverage=0.6,     # probability a targeted individual will migrate
                    duration_before_leaving=duration_before_leaving   # time to remain home before trip,
                    duration_at_node=duration_at_node,                # time to spend at destination node,
                    repetitions=1     # For a single event, set repetitions=1
                    )
```

More detail on specifying distributions for waiting/away times can be found in the [EMOD documentation - here](https://docs.idmod.org/projects/emod-malaria/en/latest/parameter-campaign-individual-migrateindividuals.html).

</p>
</details>

<details><summary><span style="color: blue;">Simulating Periodic Migration</span></summary>
<p>

For routine or seasonal migration events that repeat during a simulation, specify the number of repetitions and 
time-interval within add_migration_event():

```{python, eval=F}
add_migration_event(cb,
                    ...
                    repetitions=4,
                    tsteps_btwn=365 # annual event
                    )
```

</p>
</details>

<details><summary><span style="color: blue;">Simulating Permanent Moves</span></summary>
<p>

EMOD also has a few other parameters built-in to the migrate_individuals campaign class:

- *DontAllowDuplicates* (default is False)
    - TRUE = While waiting to leave or during a trip, another migration event can't be initialized for a given individual. 
- *IsMoving* (default is False)
    - TRUE = a migration event changes individuals "home node" that they are considered a resident of (for other node-based interventions) **nodefrom** --> **nodeto**, even if they are on a short round-trip.

<span style="color: red;">**Note:**</span> the *IsMoving* parameter doesn't have anything to do with trip duration or a permanent relocation. These migration events are all round-trips. If you want to simulate a permanent move:

- set duration_at_node in add_migration_event() to a length of time that extends past the end of your simulation.
- Make sure *DontAllowDuplicates* in MigrateIndividuals() is FALSE if you want them to be eligible for future migration events after they change residence. 
- Set *IsMoving* in MigrateIndividuals() to True.

</p>
</details>

<p>
</p>

### Monitoring migration

![figure](/images/03_highlighted.png)

<details><summary><span style="color: blue;">Tracking and counting human migrations</span></summary>
<p>

The [ReportHumanMigrationTracking](https://docs.idmod.org/projects/emod-malaria/en/latest/software-report-human-migration.html) 
custom report is available to report all human migration events, including time of migration, individual ID, origin node 
ID, destination node ID, individual's home node ID, age, infection status, and the type of migration. This report is 
very useful for counting the number of migration events to ensure the desired flux of movement is correctly specified.

```{python, eval=F}
from dtk.utils.reports.CustomReport import add_human_migration_tracking_report
add_human_migration_tracking_report(cb)
```

</p>
</details>

<details><summary><span style="color: blue;">Tracking vector migrations</span></summary>
<p>

The [ReportVectorMigration](https://docs.idmod.org/projects/emod-malaria/en/latest/software-report-vector-migration.html) 
custom report is available to report on vector migration. Note that while EMOD can model vector migration using either 
individual vectors or the vector cohort model, the ReportVectorMigration only outputs interpretable values when using the 
individual vector model. Modeling migration with cohort or individual vectors is equivalent, so we sometimes debug and 
verify migration using the individual model (**TRACK_ALL_VECTORS**), then go back to using the (faster) cohort model 
(**VECTOR_COMPARTMENTS_NUMBER**).

```{python, eval=F}
from dtk.utils.reports.VectorReport import add_vector_migration_report
cb.update_params({'Vector_Sampling_Type': 'TRACK_ALL_VECTORS',   # tell EMOD to use individual vectors
                  })
add_vector_migration_report(cb)
```

</p>
</details>



## Create climate files

Once we have generated a demographics file describing the nodes for a simulation, we can request and download weather files using the idmtools API for COMPS SSMT. The simplest way to do this is to provide your script with a csv containing the basics of the site request, including site name, latitude, longitude, and node ID, such as in the "example_site.csv" here:

|      name     |   lat   |   lon   |   nodes   |
| ------------- | ------- | ------- | --------- |
|  example_site |   1.00  |   1.00  |     1     |

This csv is passed as the `site_file` to `emodpy-malaria's` [`generate_weather()`](https://github.com/numalariamodeling/emodpy-malaria/blob/main/emodpy_malaria/weather/__init__.py) function along with the `node_column` that provides the name of our node ID column in the csv and `local_dir` which specifies that output directory. From there we can also specify:
    - `platform`: where the request work item will run (Calculon if associated with IDM)
    - `start_date` and `end_dates`: identify the period of time we are interested in requesting weather for
    - `id_reference`: specify the IDReference attribute for the weather metadata
    - `force`: flag ensuring that a new request is submitted even if the files exist in the `local_dir`

```{python, eval=F}
import tempfile
from pathlib import Path

from emodpy_malaria.weather import generate_weather

# ---| Request weather files |---

# Request weather time series, for nodes listed in a .csv file ('example_site.csv' here)
wr = generate_weather(platform="Calculon",
                      site_file="./inputs/example_site.csv",
                      start_date=2019001, #YYYYddd
                      end_date=2019365, #YYYYddd
                      node_column="nodes",
                      local_dir="./inputs/example_weather/",
                      id_reference="Gridded world grump2.5arcmin",
                      force=True)

print("\n".join(wr.files))

```

After completing these steps, there should be climate files for air_temperature, rainfall, and relative_humidity in your inputs folder. To reference these when running a simulation, update the configuration parameters to reflect the name and location of your climate files:

```{python, eval=F}
def set_param_fn(config):
    import emodpy_malaria.malaria_config as conf
    config = conf.set_team_defaults(config, manifest)
    
    #Add climate files
    config.parameters.Air_Temperature_Filename = os.path.join('climate','example_air_temperature_daily.bin')
    config.parameters.Land_Temperature_Filename = os.path.join('climate','example_air_temperature_daily.bin')
    config.parameters.Rainfall_Filename = os.path.join('climate','example_rainfall_daily.bin')
    config.parameters.Relative_Humidity_Filename = os.path.join('climate', 'example_relative_humidity_daily.bin')

    return config
```

## Individual Properties (IPs)

[Individual properties](https://docs.idmod.org/projects/emod-malaria/en/latest/model-properties.html) can be used to set specific details for individuals such as risk (i.e. high vs low access groups), cohorts, drug response groups, etc. These properties can help a simulation better reflect the reality of different sites and individuals within them and are
completely customizable.

<details><summary><span style="color: blue";">1. Adding to a demographics file</span></summary>
<p>



</p>
</details>

<details><summary><span style="color: blue";">2. Using IPs in Interventions</span></summary>
<p>


</p>
</details>

<details><summary><span style="color: blue";">3. Using IPs in Reporting</span></summary>
<p>


</p>
</details>



## Create a model - *move to top?*


## Set up mosquito species


<details><summary><span style="color: blue";">Node-Specific Habitat Scaling in Demographics</span></summary>
<p>

Node- and species-specific habitat scaling can be set in the demographics file through the NodeAttributes parameter `LarvalHabitatMultiplier`. Multipliers can be set by species as in the example below, or `'ALL_SPECIES'` to target the specified habitat for all species.

**needs demog setting instructions**

```{python, eval=F}
"NodeAttributes": {
    ...
    "LarvalHabitatMultiplier": [
        {
            "Habitat": "TEMPORARY_RAINFALL",
            "Species": "gambiae",
            "Factor": 0.1
        },
        {
            "Habitat": "BRACKISH_SWAMP",
            "Species": "arabiensis",
            "Factor": 0.5
        }
    ]
}
```

</p></details>



#update config


# reporters


## Add malaria




## Add ITN

### Basic ITN without seasonal usage



ITNs can be delivered at birth by specifying in the `coverage_by_ages` list:

```{python,eval=F}
from dtk.interventions.itn import add_ITN
add_ITN(cb,
        start=365, # starts on first day of second year
        coverage_by_ages=[
          { "birth":"birth",  # distribute at birth
            "coverage":0.5,   # 50% of newborns receive an ITN
            "duration":34}    # birth-triggered ITN program lasts for 34 days
        ],
)
```

The `waning` arguments configure the strength and duration of the ITN's effects. `dtk-tools` will provide [default](https://github.com/InstituteforDiseaseModeling/dtk-tools/blob/master/dtk/interventions/itn.py#L82) killing, blocking, and usage decay profiles if none are specified by the user:
1. `Killing_Config`: how well the ITN kills the vector
2. `Blocking_Config`: how well the ITN blocks the vector from biting
3. `Repelling_Config`: how well the ITN repels the vector
4. `Usage_Config`: how long before the user discards their net

The decay profile of any of these configs are specified using [WaningEffect classes](https://docs.idmod.org/projects/emod-malaria/en/latest/parameter-campaign-waningeffects.html).

For example, to change the killing of the ITN to last 10 years at 0.6:

```{python,eval=F}
from dtk.interventions.itn import add_ITN
add_ITN(cb,
        start=365, # starts on first day of second year
        coverage_by_ages=[
          {"coverage":1,"min": 0, "max": 10},     # 100% for 0-10 years old
          {"coverage":0.75,"min": 10, "max": 50}, # 75% for 10-50 years old
          {"coverage":0.6,"min": 50, "max": 125}  # 60% for everyone else
        ],
        waning={"Killing_Config" : {
            "Box_Duration": 3650,
            "Initial_Effect": 0.6,
            "class": "WaningEffectBox"
        }
        },
        repetitions=5, # ITN will be distributed 5 times
        tsteps_btwn_repetitions: int = 365*3 # three years between ITN distributions
)
```


### ITNs with seasonal and leaky usage

People's usage of ITN can change depending on the season, e.g., using the net more during the rainy season to reduce
nuisance bites, or they may own a net but not use it every day.
[add_ITN_age_season()](https://github.com/InstituteforDiseaseModeling/dtk-tools/blob/master/dtk/interventions/itn_age_season.py)
allows us to make fine scale usage specifications for ITNs.

While `add_itn_age_season()` is similar to `add_ITN()`, there are several differences. Instead of specifying bednet
killing, blocking and efficiency and usage all in `waning`, you specify them in separately in `killing_config`,
`blocking_config`, `repelling_config` and `discard_times`. Additionally, you specify age- and season-dependent usage with
`age_dependence` and `seasonal_dependence`.

For example:
```{python,eval=F}
from dtk.interventions.itn_age_season import add_ITN_age_season
seasonal_time = [0.0, 20.0, 21.0, 30.0, 31.0, 365.0]
seasonal_values = [1.0, 1.0, 0.5, 0.5, 1.0, 1.0]
add_ITN_age_season(cb,
                   start=365,
                   demographic_coverage=0.9,
                   killing_config={
                       "Initial_Effect": 0.6,
                       "Decay_Time_Constant": 1460,
                       "class": "WaningEffectExponential"},
                   blocking_config={
                       "Initial_Effect": 0.9,
                       "Decay_Time_Constant": 730,
                       "class": "WaningEffectExponential"},
                   discard_times={
                       "Expiration_Period_Distribution": "DUAL_EXPONENTIAL_DISTRIBUTION",
                       "Expiration_Period_Proportion_1": 0.9,
                       "Expiration_Period_Mean_1": 365*1.5,
                       "Expiration_Period_Mean_2": 3650},
                   age_dependence={'Times': [0, 5, 18],
                                  'Values': [1, 0.7, 0.2]},
                   seasonal_dependence={"Times": seasonal_times, "Values": seasonal_values}
)
```

In this example, the baseline coverage of ITN is 0.9 specified by `demographic_coverage`. This means that 90% of the
population will receive an ITN for use. Usage by age starts highest at 0 years old with a scale of 1 (Note actual
usage is 1 * 0.9 = 0.9) and *linearly* declines to 0.7 at age of 5 years, and then continues to decline to 0.2 at age of
18 and remains at 0.2 for those over 18.

For season-dependent usage, in this example, usage is 1 throughout the year except between day 21 and day 30 when
usage is 0.5. Each individual who owns a net uses it with probability of their age-dependent usage value and the
season-dependent usage value.

The `add_itn_age_season()` function *does not* support repetitions. Therefore, to add multiple rounds of ITN distribution
in your simulation, you need to call `add_ITN_age_season()` multiple times. Another difference is this function *will*
automatically add three events into the simulation: `Bednet_Discarded`, `Bednet_Got_New_One` and `Bednet_Using`.


## Add IRS

IRS campaigns can be added using the `add_scheduled_irs_housing_modification` or `add_triggered_irs_housing_modification` function. These two functions work similarly, with the primary difference being how IRS implementaiton is timed: on a schedule or triggered by specific events.

***edit for modified structure - not config/waning but indiv params***
You can either use the default settings or specify the `killing_config` for the killing efficiency and waning properties
of the insecticide. The function allows you to specify coverage according to age groups, here is an example:

```{python,eval=F}
from dtk.interventions.irs import add_IRS
add_IRS(cb,
        start=366, # IRS occurs on first day of second year
        coverage_by_ages=[
          {"coverage":1,"min": 0, "max": 10},     # 100% for 0-10 years old
          {"coverage":0.75,"min": 11, "max": 50}, # 75% for 11-50 years old
          {"coverage":0.6,"min": 51, "max": 125}  # 60% for everyone else
        ],
        killing_config={
            "class": "WaningEffectBoxExponential",
            "Box_Duration": 60,
            "Decay_Time_Constant": 120,
            "Initial_Effect": 0.6
        }
)
import emod_api.campaign as campaign
add_scheduled_irs_housing_modification(campaign, start_day=3, 
                                       demographic_coverage=0.34,
                                       killing_initial_effect=0.9, 
                                       killing_box_duration=30,
                                       killing_decay_time_constant=60, 
                                       repelling_initial_effect=0.2,
                                       repelling_box_duration=60, 
                                       repelling_decay_time_constant=0)
add_triggered_irs_housing_modification(campaign=campaign, start_day=2, 
                                       demographic_coverage=0.77,
                                       trigger_condition_list=["HappyBirthday"],
                                       listening_duration=15,
                                       delay_period_constant=3, 
                                       killing_initial_effect=0.8,
                                       killing_box_duration=30, 
                                       killing_decay_time_constant=60,
                                       repelling_initial_effect=0.33, 
                                       repelling_box_duration=60,
                                       repelling_decay_time_constant=30)
```

Note in this case, the effect of IRS follows [a boxed exponential decay](https://docs.idmod.org/projects/emod-generic/en/latest/parameter-campaign-waningeffects.html?highlight=waning#waningeffectboxexponential)
with efficacy of first 60 days held constant, before exponential decay kicks in.


## Add larvicides

Functions for adding attractive targeted sugar baits, topical repellents, outdoor residual spray, eave tubes, and larvicides are found [here](https://github.com/InstituteforDiseaseModeling/dtk-tools/blob/master/dtk/interventions/novel_vector_control.py).

To add larvicides: 

```{python,eval=F}
from dtk.utils.core.DTKConfigBuilder import DTKConfigBuilder
from dtk.interventions.novel_vector_control import add_larvicides
cb = DTKConfigBuilder.from_defaults('MALARIA_SIM')
add_larvicides(cb, start_day=0, 
               habitat_target='CONSTANT',   # habitat type to target
               killing_initial=0.6,         # initial killing efficacy of the insecticide
               killing_decay=150            # decay time constant, in days, for exponential decay of larvicide efficacy
               )
add_larvicide(
        campaign,
        start_day: int = 1,
        num_repetitions: int = -1,
        timesteps_between_reps: int = 365,
        spray_coverage: float = 1.0,
        killing_effect: float = 1,
        habitat_target: str = "ALL_HABITATS",
        insecticide: str = None,
        box_duration: int = 100,
        decay_time_constant: float = 0.0,
        node_ids: list = None
    )
```


## Add insecticide resistance 

![figure](/images/04_highlighted.png)

Modeling insecticide resistance involves 3 steps:
1. Set up vector genetics
2. Relate genotypes to phenotype: define insecticide response of resistance genotypes
3. Add intervention that distributes insecticide (vector control)

**note: added 1&2 to vector guide, 3 should go in interventions?**

### Set up vector genetics



### Relate genotype to phenotype


### Add vector control with specific insecticide

Specify the insecticide when adding vector control:

```{python,eval=F}
from dtk.interventions.itn import add_ITN
add_ITN(cb, start=0, coverage_by_ages=[{'min': 0, 'max': 100, 'coverage': 0.6}],
        insecticide='pyrethroid')
add_ITN(cb, start=100, coverage_by_ages=[{'min': 0, 'max': 100, 'coverage': 0.6}],
        insecticide='pyrethroid-PBO')
add_ITN(cb, start=200, coverage_by_ages=[{'min': 0, 'max': 100, 'coverage': 0.6}],
        insecticide='carbamate')
```

## Add case management



## Change drug adherence


## Add drug campaigns



## Add diagnostic surveys


## Add vaccine

Malaria vaccines can be added using the [add_vaccine()](https://github.com/InstituteforDiseaseModeling/dtk-tools-malaria/blob/master/malaria/interventions/malaria_vaccine.py#L19) function.
The function is generic: it can handle pre-erythrocytic vaccines, transmission-blocking vaccines, and RTS,S specifically.
Initial efficacy and decay parameters for RTS,S are set to the EMOD parameterization in Penny et al. 2016.

In this example, a mass campaign is given at 80% coverage on day 365:
```{python, eval=F}
from malaria.interventions.malaria_vaccine import add_vaccine
add_vaccine(cb,
            vaccine_type='RTSS',
            start_days=[365],
            coverage=0.8)
            
import emod_api.campaign as campaign
import emodpy_malaria.interventions.vaccine as vaccine            
vaccine.add_scheduled_vaccine(campaign,
                          start_day: int = 1,
                          demographic_coverage: float = 1.0,
                          target_num_individuals: int = None,
                          node_ids: list = None,
                          repetitions: int = 1,
                          timesteps_between_repetitions: int = 365,
                          ind_property_restrictions: list = None,
                          target_age_min: int = 0,
                          target_age_max: int = 125,
                          target_gender: str = "All",
                          broadcast_event: str = None,
                          vaccine_type: str = "AcquisitionBlocking",
                          vaccine_take: float = 1,
                          vaccine_initial_effect: float = 1,
                          vaccine_box_duration: int = 365,
                          vaccine_decay_time_constant: float = 100,
                          efficacy_is_multiplicative: bool = True)

vaccine.add_triggered_vaccine(campaign,
                          start_day: int = 1,
                          trigger_condition_list: list = None,
                          listening_duration: int = -1,
                          delay_period_constant: float = 0,
                          demographic_coverage: float = 1.0,
                          node_ids: list = None,
                          repetitions: int = 1,
                          timesteps_between_repetitions: int = 365,
                          ind_property_restrictions: list = None,
                          target_age_min: int = 0,
                          target_age_max: int = 125,
                          target_gender: str = "All",
                          broadcast_event: str = None,
                          vaccine_type: str = "AcquisitionBlocking",
                          vaccine_take: float = 1,
                          vaccine_initial_effect: float = 1,
                          vaccine_box_duration: int = 365,
                          vaccine_decay_time_constant: float = 100,
                          efficacy_is_multiplicative: bool = True)
```


### Distributing RTS,S through age-based immunization

The RTS,S vaccine schedule is relatively complex, including a 3-dose primary schedule ending at 9 months of age and one
or more boosters.

The example below specifies an RTS,S vaccine campaign starting day 365. From this day on, any newborn baby will be
marked as `RTSS_3rddose_eligible` on 270 days old. The child will be given 3rd dose of RTS,S (first two doses don't
matter due to the assumption of zero efficacy until dose 3) at 80% probability. Any child who receives a dose of
vaccine also receives the event `Received_Vaccine`, which is specified in `add_vaccine()`.

Because only children who receive third dose vaccine would go on to receive a booster, we use individual properties to
keep track of who is eligible for a booster. In other parts of the code, we set up an
[individual property](https://faculty-enrich-2022.netlify.app/modules/emod-how-to/emod-how-to/#individual-properties)
`VaccineStatus` that can have be `None` or `GotVaccine`. We use the
`change_individual_property` function to switch someone with the individual property `VaccineStatus` of `None` to `GotVaccine`,
when they `Received_Vaccine`.

```{python, eval=F}
from malaria.interventions.malaria_vaccine import add_vaccine
from dtk.interventions.property_change import change_individual_property
add_vaccine(cb,
            vaccine_type='RTSS',
            start_days=365,
            coverage=0.8,
            triggered_delay=270,
            trigger_condition_list=["RTSS_3rddose_eligible"],
            birthtriggered=True)
change_individual_property(cb,
                           target_property_name='VaccineStatus',
                           target_property_value='GotVaccine',
                           ind_property_restrictions=[{'VaccineStatus': 'None'}],
                           trigger_condition_list=['Received_Vaccine'],
                           blackout_flag=False)

change_individual_property_triggered( camp,
                                          triggers: list,
                                          new_ip_key: str,
                                          new_ip_value: str,
                                          start_day: int=0, 
                                          daily_prob: float=1,
                                          max_duration: int=9.3228e+35,
                                          revert_in_days:int=-1,

                                          node_ids: list=None, # where

                                          ip_restrictions:list=None,
                                          coverage: float=1.0,
                                          target_age_min: float=0,
                                          target_age_max: float=_MAX_AGE,
                                          target_sex: str="All",
                                          target_residents_only: bool=False,

                                          delay=None,
                                          listening_duration: int=-1,
                                          blackout: bool=True,
                                          check_at_trigger: bool=False
    )
```

Those who have received their 3rd dose of vaccine are eligible for a booster at the age of 2 years (730 days) old. The
`ind_property_restrictions` argument is used to ensure that only those with `VaccineStatus` of `GotVaccine` receive the booster.
`change_individual_property` is then used change `VaccineStatus` to `GotBooster1`, which helps bookkeeping and is
particularly important in the event that they are to receive additional boosters.

```{python, eval=F}
add_vaccine(cb,
            vaccine_type='RTSS',
            start_days=366,
            coverage=0.8,
            triggered_delay=730,
            trigger_condition_list=["RTSS_booster1_eligible"],
            ind_property_restrictions=[{'VaccineStatus': 'GotVaccine'}],
            birthtriggered=True)
change_individual_property(cb,
                           target_property_name='VaccineStatus',
                           target_property_value='GotBooster1',
                           ind_property_restrictions=[{'VaccineStatus': 'GotVaccine'}],
                           trigger_condition_list=['Received_Vaccine'],
                           blackout_flag=False)
```



## Triggered interventions - likely remove because specific ones

![figure](/images/04_highlighted.png)

Following code is an example of event triggered bednet distribution, that from the first day of second year in
simulation onwards, a clinical or severe case would receive a bednet 14 days after diagnosis:
```{python,eval=F}
add_ITN(cb,
        start=366,
        triggered_campaign_delay=14,
        trigger_condition_list=["NewClinicalCase", "NewSevereCase"],
        duration=365)
```

`duration=365` means the event-triggered distribution of bed net will be going on till the following year. Setting
`duration=-1` will allow the campaign to go on until the end of simulation.


## Using the model builder to set up multi-simulation experiments

We often want to run a series of simulations where most parameters are held constant but one or more are varied. To set 
this up in a `dtk-tools` script, we use a `builder` and the `ModBuilder` function with associated `ModFn`s.

All model parameters can be varied ("swept through") with the `ModBuilder`: config, campaign, and even custom report output 
parameters. A few example uses are shown below.

### Set the number of stochastic realizations (replicates) to run

The **Run_Number** config parameter sets the simulation's random seed. To run multiple stochastic realizations of the same simulation, vary **Run_Number** in the builder. In this example, the builder creates 10 identical simulations except for the value of **Run_Number**, which ranges from 0-9.

```{python, eval=F}
from emodpy.emod_task import EMODTask
from idmtools.builders import SimulationBuilder
from idmtools.entities.experiment import Experiment

def set_param(simulation, param, value):
    # sets a specific config parameter to the specified value, useful for sweeps
    return simulation.task.set_parameter(param, value)

num_seeds = 10
builder = SimulationBuilder()
    
builder.add_sweep_definition(partial(set_param, param='Run_Number'), range(num_seeds))

# create experiment from builder
experiment = Experiment.from_builder(builder, task, name="multi_seed_experiment")
```

### Sweeping through multiple config parameters

In this example, we sweep through 20 values of **x_Temporary_Larval_Habitat** and 10 **Run_Number** values/stochastic realizations for each habitat value, creating 200 total simulations.

```{python, eval=F}
from emodpy.emod_task import EMODTask
from idmtools.builders import SimulationBuilder
from idmtools.entities.experiment import Experiment

import numpy as np

def set_param(simulation, param, value):
    # sets a specific config parameter to the specified value, useful for sweeps
    return simulation.task.set_parameter(param, value)

num_seeds = 10
builder = SimulationBuilder()
    
builder.add_sweep_definition(partial(set_param, param='Run_Number'), range(num_seeds))
builder.add_sweep_definition(partial(set_param, param='x_Temporary_Larval_Habitat'), np.logspace(-2, 2, 20))

# create experiment from builder
experiment = Experiment.from_builder(builder, task, name="multi_habitat_and_seed_experiment")
```

### Setting up complex sweeps

The following model builder implements specific functions from the NU team's SMC work. Two wrapper functions, `smc_intervention` and `set_EIR`, have been defined since this user doesn't need to vary over every argument in `add_drug_campaign` or `add_InputEIR`. Note that these wrapper functions *must* return a dictionary for the `ModBuilder` to function correctly.

```{python,eval=F}
import numpy as np
from dtk.utils.core.DTKConfigBuilder import DTKConfigBuilder
from simtools.ModBuilder import ModBuilder, ModFn
from malaria.interventions.malaria_drug_campaigns import add_drug_campaign
from dtk.interventions.input_EIR import add_InputEIR, monthly_to_daily_EIR
expt_name = 'SMC_EIR_sweep'
numseeds = 10 
cb = DTKConfigBuilder.from_defaults('MALARIA_SIM')
def smc_intervention(cb, day, cycles, coverage_level) :
    add_drug_campaign(cb, campaign_type='SMC',
                      coverage=coverage_level, start_days=[365 + day],
                      repetitions=cycles, 
                      tsteps_btwn_repetitions=30,
                      target_group={'agemin': 0.25, 'agemax': 5},
                      receiving_drugs_event_name='Received_SMC')
    return { 'SMC_coverage' : coverage_level}
def set_EIR(cb, EIRscale_factor) :
    monthly_site_EIR = [15.99, 5.41, 2.23, 10.33, 7.44, 11.77, 79.40, 85.80, 118.59, 82.97, 46.62, 33.49]
    daily_EIR = monthly_to_daily_EIR(monthly_site_EIR)
    add_InputEIR(cb, start_day=0, EIR_type='DAILY', dailyEIRs=daily_EIR, scaling_factor=EIRscale_factor)
    return { 'EIR_scale_factor' : EIRscale_factor}
builder = ModBuilder.from_list([[ModFn(smc_intervention, day=213, cycles=4, coverage_level=smc_coverage),
                                 ModFn(set_EIR, EIRscale_factor=eir_scale_factor),
                                 ModFn(DTKConfigBuilder.set_param, 'Run_Number', x),
                                 ]
                                for smc_coverage in [0.5, 0.9]
                                for eir_scale_factor in [0.2, 2]
                                for x in range(numseeds)
                                ])
run_sim_args = {
    'exp_name': expt_name,
    'config_builder': cb,
    'exp_builder' : builder
}
```


## Setting up the experiment manager - maybe change to be earlier (we introduce with sweeping currently)

![figure](/images/06_highlighted.png)

The experiment manager serves as a mechanism to actually run simulations using the model and config builders. The respective builders, "builder" and "cb", are set up earlier in this list.

```{python,eval=F}
from simtools.SetupParser import SetupParser
from simtools.ExperimentManager.ExperimentManagerFactory import ExperimentManagerFactory
Exp_name = 'my_experiment_name'
cb = DTKConfigBuilder.from_defaults('MALARIA_SIM')
builder = ModBuilder.from_list(...) # builder is optional
run_sim_args = {
    'exp_name': Exp_name,
    'config_builder': cb,
    'exp_builder' : builder         # delete this line if not using a builder
}
if __name__ == "__main__":
    SetupParser.init()
    exp_manager = ExperimentManagerFactory.init()
    exp_manager.run_simulations(**run_sim_args)
```


## Serialization

![figure](/images/02_highlighted.png)

Some simulations can take a long time to run and the part you are really interested in analyzing isn’t until closer to the end. You’d like to save the state of the simulation just before the interesting stuff and then restart from that spot. This would allow you to iterate more quickly on different intervention strategies or just trying to understand what the simulation is doing better. EMOD supports this ability with a feature called “serialized populations.”

The serialized population feature in EMOD allows you to save the state of the people and restart from that saved state. This state includes the person’s health, infections, any interventions that they have, and more. This is especially useful when you need to create a population that has natural immunity to a pathogen (i.e. the pathogen is not novel and the population is not naive.) 

### Simple Burn-in

To create a population with an endemic disease, we start with a naive population and run the simulation till disease dynamics reach an equilibrium, usually around 50 years.

For the initial burn-in simulation, you need to tell EMOD that you would like it to save a serialized population and at what timestep(s), in this case the last day of the simulation.

```{python,eval=F}
serialize_years = 50 # Number of years to run burn-in

#put the following in config builder
    
#Add serialization - add burnin "write" parameters to config.json
config.parameters.Serialized_Population_Writing_Type = "TIMESTEP"
config.parameters.Serialization_Time_Steps = [365 * serialize_years]
config.parameters.Serialization_Mask_Node_Write = 0
config.parameters.Serialization_Precision = "REDUCED"
```

Then, run this simulation as you would any other. When the simulation has succeeded, the output/ directory should contain a state-*.dtk file, where * is the 5-digit date of serialization. In this example, a state-18250.dtk file would be created.

### Picking up from Serialized Burn-in

To pick up from the end of a saved burn-in simulation, and run for some additional time, you need the name of the state*.dtk file from the burn-in and the path to the .dtk file. If you know the path to the .dtk file, you can specify it directly:

```{python,eval=F}
burnin_id = <ExperimentID> # replace with burn-in ID
# Number of years from burn-in to include.
serialize_year = 50 # number of years used in first burn-in simulation, NOT number of years to run pick-up
cb.update_params({
            'Serialized_Population_Reading_Type': 'READ',
            'Serialized_Population_Filenames': ['state-%05d.dtk' % (serialize_year*365)],
            'Serialized_Population_Path': '.../output/',   # where ... is the path to the state-*.dtk file
            'Enable_Random_Generator_From_Serialized_Population': 0,
            'Serialization_Mask_Node_Read': 0,
            'Enable_Default_Reporting' : 0
        })
serialize_years = 50 # Number of years to run burn-in

#put the following in config builder
#add serialization - add pickup "read" parameters to config.json
config.parameters.Serialized_Population_Reading_Type = "READ"
config.parameters.Serialization_Mask_Node_Read = 0
config.parameters.Serialization_Time_Steps = [serialize_years*365]
```

If you know the experiment ID of your burn-in simulation, you can use that instead through the `retrieve_experiment` 
function, updating other serialization parameters as above: 

```{python,eval=F}
from simtools.Utilities.Experiments import retrieve_experiment
import os
burnin_id = '...' # alphanumeric string
expt = retrieve_experiment(burnin_id) # Identifies the desired burn-in experiment
output_paths = [sim.get_path() for sim in expt.simulations]
cb.update_params({
            ...
            'Serialized_Population_Path': os.path.join(output_paths[0], 'output')     # takes the first simulation in the experiment
        })


```

If you ran a burn-in experiment that varied key parameters that you would like to also reuse during pickup, you can incorporate setting the `Serialized_Population_Path` in the builder:

```{python, eval=F}
from simtools.Utilities.Experiments import retrieve_experiment
import os
burnin_id = '...' # alphanumeric string
serialize_year = 50 # number of years used in first burn-in simulation, NOT number of years to run pick-up
expt = retrieve_experiment(burnin_id) # Identifies the desired burn-in experiment
cb.update_params({
            'Serialized_Population_Reading_Type': 'READ',
            'Serialized_Population_Filenames': ['state-%05d.dtk' % (serialize_year*365)],
            'Enable_Random_Generator_From_Serialized_Population': 0,
            'Serialization_Mask_Node_Read': 0,
            'Enable_Default_Reporting' : 0
        })
ser_df = pd.DataFrame([x.tags for x in expt.simulations])  # tags distinguish between burn-in scenarios (ex. varied historical coverage levels)
ser_df["outpath"] = pd.Series([sim.get_path() for sim in expt.simulations])
builder = ModBuilder.from_list([[...,
              ...,
              ModFn(DTKConfigBuilder.set_param, 'Serialized_Population_Path', os.path.join(row['outpath'], 'output')),
              # set other ModFn()s to incorporate desired data from tags
              ...],
          for r,row in ser_df.iterrows()   # Run pick-up from each unique burn-in scenario
          ])


from utils_slurm import build_burnin_df ##for slurm, needs adding to emodpy or moving from example

def update_serialize_parameters(simulation, df, x: int):
    path = df["serialized_file_path"][x]
    seed = int(df["Run_Number"][x])
    
    simulation.task.set_parameter("Serialized_Population_Filenames", df["Serialized_Population_Filenames"][x])
    simulation.task.set_parameter("Serialized_Population_Path", os.path.join(path, "output"))
    simulation.task.set_parameter("Run_Number", seed) #match pickup simulation run number to burnin simulation

    return {"Run_Number":seed}

#in general simulation creation:
#create burnin df, retrieved from burnin ID (defined above)
burnin_df = build_burnin_df(burnin_exp_id, platform, serialize_years*365)

builder.add_sweep_definition(partial(update_serialize_parameters, df=burnin_df), range(len(burnin_df.index)))
```


## Analyze experiments


### Analyze ReportEventRecorder

The ReportEventRecorder is in csv format instead of json and includes events for each single individual in the simulation per event that happened. Some individuals occur multiple times in the csv file while other might not appear even once, depending on the events specified (i.e. if `Births` are specified every new individual born in the simulation will appear once).

In this example, we look for the event `Received_Severe_Treatment` and count the number of events by age group. We also account for the case where none of these events occurred during the simulation.

```{python, eval=F}
class IndividualEventsAnalyzer(IAnalyzer):
    def __init__(self, expt_name, agebins=None,
                 sweep_variables=None, working_dir=".", start_year=2010, end_year=2020):
        super(IndividualEventsAnalyzer, self).__init__(working_dir=working_dir,
                              filenames=["output/ReportEventRecorder.csv"]
                                                       )
        self.sweep_variables = sweep_variables or ["Run_Number"]
        self.event_name = 'Received_Severe_Treatment'
        self.agebins = agebins or [1, 5, 200]
        self.expt_name = expt_name
        self.start_year = start_year
        self.end_year = end_year
        
    def map(self, data, simulation):
        output_data = data[self.filenames[0]]
        output_data = output_data[output_data['Event_Name'] == self.event_name]
        simdata = pd.DataFrame()
        if len(output_data) > 0:  # there are events of this type
            output_data['Day'] = output_data['Time'] % 365
            output_data['month'] = output_data['Day'].apply(lambda x: self.monthparser((x + 1) % 365))
            output_data['year'] = output_data['Time'].apply(lambda x: int(x / 365) + self.start_year)
            output_data['age in years'] = output_data['Age'] / 365
            for agemax in self.agebins:
                if agemax < 200:
                    agelabel = 'U%d' % agemax
                else:
                    agelabel = 'all_ages'
                if agemax == 5:
                   agemin = 0.25
                else:
                    agemin = 0
                d = output_data[(output_data['age in years'] < agemax) & (output_data['age in years'] > agemin)]
                g = d.groupby(['year', 'month'])['Event_Name'].agg(len).reset_index()
                g = g.rename(columns={'Event_Name': 'Num_%s_Received_Severe_Treatment' % agelabel})
                if simdata.empty:
                    simdata = g
                else:
                    if not g.empty :
                        simdata = pd.merge(left=simdata, right=g, on=['year', 'month'], how='outer')
                        simdata = simdata.fillna(0)
            for sweep_var in self.sweep_variables:
                if sweep_var in simulation.tags.keys():
                    simdata[sweep_var] = simulation.tags[sweep_var]
        else:
            simdata = pd.DataFrame(columns=['year', 'month', 'Num_U5_Received_Severe_Treatment',
                                            'Num_U1_Received_Severe_Treatment',
                                            'Num_all_ages_Received_Severe_Treatment'] + self.sweep_variables)
        return simdata
```
